class Solution {
    func reverseList(_ head: ListNode?) -> ListNode? {
        var prev: ListNode? = nil
        var curr = head
        var next: ListNode? = nil

        while curr != nil {
            // 다음 노드를 저장
            next = curr?.next
            // 현재 노드의 다음 노드를 이전 노드로 변경
            curr?.next = prev
            // 이전 노드를 현재 노드로 이동
            prev = curr
            // 현재 노드를 다음 노드로 이동
            curr = next
        }
        return prev
    }
}

// 처음에는 배열인 줄 알고 reverse() 메서드를 사용
// reverse()와 reversed()
// reverse() : 배열 자체를 뒤집는 메소드로 원본 배열이 수정된다.
// reversed() : ReversedCollection 타입을 반환하기 때문에 배열로 사용하기 위해서는 Array 생성자를 사용해 명시적으로 변환해야한다.

// 배열과 단일 연결 리스트

// 배열 
// 메모리 구조 : 메모리의 연속된 블록에 저장되어 인덱스로 접근 가능하다. 각 요소는 메모리에서 인접한 위치에 저장된다.
// 접근 시간 : O(1) 시간 복잡도로 임의의 인덱스에 접근 가능
// 삽입과 삭제 : 요소 이동이 필요하여 O(N)의 시간복잡도를 가짐

// 단일 연결 리스트
// 메모리 구조 : 메모리의 임의의 위치에 저장(인접하지 않을 수)될 수 있어 노드는 다음 노드를 가리키는 포인터가 포함된다.
// 접근 시간 : 첫 번째 노드부터 순차적으로 접근해야하기 때문에 최대 O(N)의 시간이 걸릴 수 있다.
// 삽입과 삭제 : 해당 위치의 노드만 조작하면 되기 때문에 O(1)의 시간 복잡도를 가진다.

// ListNode? 옵셔널로 사용하는 이유
// 연결 리스트의 끝을 표시하기 위해서 사용한다. 마지막 노드의 next가 nil값을 가져야한다.
// 빈 리스트를 표현해야한다. 리스트의 head가 nil값이어야 한다.
// 다음 노드가 없다는 것을 표시하기 위해서 사용한다. 특정 노드가 다음 노드를 가리키지 않게 하려면 해당 노드의 next를 nil로 설정해야한다.

// curr? 옵셔널로 사용하는 이유
// 리스트의 끝에 도달했을 때 next가 nil값을 가져야한다.
// 빈 리스트를 처리하기 위해서 사용한다. 연련 리스트가 비어있으면 head는 nil값을 가지고 curr를 head로 초기화할 때 curr가 nil값이 된다.